<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sayxit</title>
  <link rel="icon" type="image/png" href="assets/favicon.png">
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #webcam, #fallback {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover; background: #000;
    }
    .logo-top { position: fixed; top: 5px; left: 50%; transform: translateX(-50%); z-index: 3; }
    .logo-top img { max-width: 140px; height: auto; display:block; }
    #overlayCanvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }
    .footer { position: fixed; left:0; right:0; bottom:14px; display:flex; justify-content:center; gap:14px; z-index:3; }
    .footer a { width:22px; height:22px; display:block; }
    .footer a.social img { filter: invert(1); }
    .footer img { width:22px; height:22px; display:block; object-fit:contain; }
    .overlay { position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.6); color:#fff; z-index:4; font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .overlay.hidden { display:none; }
    #startBtn { position:fixed; bottom:70px; left:50%; transform:translateX(-50%); z-index:5; background:#fff; color:#000; border:0; border-radius:999px; padding:10px 16px; font-weight:600; cursor:pointer; }
  </style>

  <style id="clickfix">
    #glcanvas, #fxcanvas, canvas.stage { pointer-events: none !important; }
    video#webcam, video#fallback { pointer-events: none !important; }
    .top-logo, #top-logo { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; pointer-events: auto !important; }
    .top-logo a, #top-logo a { display: inline-block; }
  </style>

  <style id="overlayfix">
    .overlay { pointer-events: none !important; }
  </style>
</head>
<body>
  <video id="webcam" autoplay playsinline muted></video>
  <video id="fallback" autoplay playsinline muted loop style="display:none">
    <source src="assets/fallback.mp4" type="video/mp4" />
  </video>

  <canvas id="overlayCanvas"></canvas>

  <div class="logo-top"><a href="https://sayxit.com" target="_blank" rel="noopener"><img src="assets/top_logo.png" alt="SayXit Logo"></a></div>

  <div id="overlay" class="overlay"><div>Turn on your camera fam âœ¨</div></div>
  <button id="startBtn">Start</button>

  <div class="footer">
    <a class="social" href="https://www.instagram.com/sayxit/" target="_blank" rel="noopener"><img src="assets/instagram.svg" alt="Instagram"></a>
    <a class="social" href="https://www.tumblr.com/sayxit" target="_blank" rel="noopener"><img src="assets/tumblr.svg" alt="Tumblr"></a>
    <a href="mailto:selim@sayxit.com" rel="noopener"><img src="assets/email.png" alt="Email"></a>
    <a class="social" href="https://www.tiktok.com/@sayxit" target="_blank" rel="noopener"><img src="assets/tiktok.svg" alt="Tiktok"></a>
    <a class="social" href="https://www.youtube.com/@sayxxit" target="_blank" rel="noopener"><img src="assets/youtube.svg" alt="YouTube"></a>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  const webcam = document.getElementById('webcam');
  const fallback = document.getElementById('fallback');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const ocan = document.getElementById('overlayCanvas');
  const octx = ocan.getContext('2d');
  const headImg = new Image(); headImg.src = 'assets/head_logo.png';

  // Hi-DPI aware resize (crisper on Retina; same CSS size)
  function resize(){
    const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    ocan.style.width  = innerWidth + 'px';
    ocan.style.height = innerHeight + 'px';
    ocan.width  = Math.round(innerWidth  * DPR);
    ocan.height = Math.round(innerHeight * DPR);
    octx.setTransform(DPR, 0, 0, DPR, 0, 0); // draw in CSS pixels
  }

  // Responsive halo behavior (phone/tablet/desktop)
  const HALO_CFG = {
    liftByHeadWidth: 0.95,
    sizeByHeadWidth: 3.50,
    smoothPosAlpha: 0.18,
    smoothScaleAlpha: 0.20,
    visibilityMin: 0.35 // lowered to keep smaller/farther faces
  };
  function updateHaloResponsive(){
    const shortSide = Math.min(innerWidth, innerHeight);
    if (shortSide < 500) {           // phones
      HALO_CFG.sizeByHeadWidth = 4.30;
      HALO_CFG.liftByHeadWidth = 1.05;
    } else if (shortSide < 900) {    // small tablets
      HALO_CFG.sizeByHeadWidth = 3.90;
      HALO_CFG.liftByHeadWidth = 1.00;
    } else {                         // laptops/desktops
      HALO_CFG.sizeByHeadWidth = 3.50;
      HALO_CFG.liftByHeadWidth = 0.95;
    }
  }

  function handleResize(){
    resize();
    updateHaloResponsive();
  }
  addEventListener('resize', handleResize, {passive:true});
  handleResize();

  async function startCamera(){
    try {
      // HD constraints -> better small-face detection
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:'user', width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      webcam.srcObject = stream; await webcam.play();
      overlay.classList.add('hidden'); startBtn.style.display='none'; fallback.style.display='none';
      initFace();
    } catch(e){
      overlay.classList.add('hidden'); startBtn.style.display='inline-block';
      fallback.style.display='block'; try{ await fallback.play(); }catch{}
    }
  }
  document.addEventListener('DOMContentLoaded', startCamera);
  startBtn.addEventListener('click', startCamera);

  // Breathing halo controls (4s cycle unchanged)
  let __haloT0 = performance.now();
  const GLOW = {
    BLUR_MIN: 0,
    BLUR_MAX: 60,
    ALPHA_MIN: 0.35,
    ALPHA_MAX: 1.0,
    SPEED_HZ: 0.25,
    CLIP_PAD_PX: 140
  };

  // --- Multi-face tracking (EMA per face) ---
  const HALO_MAX_FACES = 8;                  // draw up to 8 halos
  function matchRadiusPx(){ return Math.max(220, Math.min(innerWidth, innerHeight) * 0.08); }
  const TRACK_TTL_MS   = 450;
  let haloTracks = []; // [{x,y,w,h,scale,lastSeen,ax,ay}]
  const nowMs = () => performance.now();

  function matchTrack(ax, ay){
    const R = matchRadiusPx();
    let best=null, bestD=1e9, bestIdx=-1;
    for (let i=0;i<haloTracks.length;i++){
      const tr = haloTracks[i];
      const d = Math.hypot(tr.ax - ax, tr.ay - ay);
      if (d < bestD && d <= R) { bestD = d; best = tr; bestIdx = i; }
    }
    return { track: best, index: bestIdx };
  }
  function pruneTracks(){
    const t = nowMs();
    haloTracks = haloTracks.filter(tr => (t - tr.lastSeen) < TRACK_TTL_MS);
  }

  const lerp = (a,b,t)=> (a==null ? b : a + (b-a)*t);
  const px   = v => Math.round(v); // snap to integers to reduce shimmer

  function drawHeads(lmsList){
    octx.clearRect(0,0,ocan.width,ocan.height);
    if(!lmsList || !lmsList.length || !headImg.complete) { pruneTracks(); return; }

    // Breathing glow (shared by all halos)
    const tNow = (performance.now() - __haloT0) * 0.001;
    const s    = Math.sin(tNow * 2 * Math.PI * GLOW.SPEED_HZ) * 0.5 + 0.5;
    const blur = GLOW.BLUR_MIN  + (GLOW.BLUR_MAX  - GLOW.BLUR_MIN)  * s;
    const alpha= GLOW.ALPHA_MIN + (GLOW.ALPHA_MAX - GLOW.ALPHA_MIN) * s;

    // Sort faces by apparent size (largest first) and clamp
    const faces = lmsList
      .map(lm => {
        const L = lm[127], R = lm[356];
        const headW = Math.hypot((R.x - L.x)*innerWidth, (R.y - L.y)*innerHeight);
        return { lm, headW };
      })
      .sort((a,b)=>b.headW - a.headW)
      .slice(0, HALO_MAX_FACES);

    faces.forEach(({lm})=>{
      // Confidence gate
      if (lm[10].visibility !== undefined && lm[10].visibility < HALO_CFG.visibilityMin) return;

      // Head width from temples; eyes as fallback
      const L = lm[127], R = lm[356];
      const eyeL = lm[33], eyeR = lm[263];
      const headW = Math.hypot((R.x - L.x) * innerWidth, (R.y - L.y) * innerHeight);
      const eyeW  = Math.hypot((eyeR.x - eyeL.x) * innerWidth, (eyeR.y - eyeL.y) * innerHeight);
      const baseScale = headW > 0 ? headW : eyeW;

      // Anchor near forehead (nose bridge top blended with brow)
      const noseTop = lm[10];
      const browMid = lm[151] || lm[9];
      const ax = ((noseTop.x + browMid.x) * 0.5) * innerWidth;
      const ay = (Math.min(noseTop.y, browMid.y)) * innerHeight;

      // Boost for small/distant faces so halo reads clearly
      const SMALL_FACE_PX = 120;
      const boost = Math.min(1.8, Math.max(1.0, SMALL_FACE_PX / Math.max(1, baseScale)));

      // Target geometry (device-agnostic via head width, with boost)
      const size = HALO_CFG.sizeByHeadWidth * baseScale * boost;
      const lift = HALO_CFG.liftByHeadWidth * baseScale * (0.9 + 0.1 * boost);

      const tw = size;
      const th = tw * (headImg.height / headImg.width);
      const tx = ax - tw / 2;
      const ty = (ay - lift) - th / 2;

      // Match or create a track, with adaptive smoothing for small faces
      const {track} = matchTrack(ax, ay);
      const posA   = baseScale < SMALL_FACE_PX ? HALO_CFG.smoothPosAlpha   * 0.7 : HALO_CFG.smoothPosAlpha;
      const scaleA = baseScale < SMALL_FACE_PX ? HALO_CFG.smoothScaleAlpha * 0.7 : HALO_CFG.smoothScaleAlpha;

      let tr = track;
      if (!tr) {
        tr = { x:tx, y:ty, w:tw, h:th, scale:baseScale, lastSeen:nowMs(), ax, ay };
        haloTracks.push(tr);
        if (haloTracks.length > HALO_MAX_FACES) haloTracks.shift();
      } else {
        tr.scale = lerp(tr.scale, baseScale, scaleA);
        tr.w     = lerp(tr.w, tw,       scaleA);
        tr.h     = lerp(tr.h, th,       scaleA);
        tr.x     = lerp(tr.x, tx,       posA);
        tr.y     = lerp(tr.y, ty,       posA);
        tr.ax    = lerp(tr.ax, ax,      posA);
        tr.ay    = lerp(tr.ay, ay,      posA);
        tr.lastSeen = nowMs();
      }

      // Pixel snap to reduce shimmer
      const X = px(tr.x), Y = px(tr.y), W = px(tr.w), H = px(tr.h);

      // Draw with local clip (glow contained)
      octx.save();
      octx.beginPath();
      const pad = GLOW.CLIP_PAD_PX;
      octx.rect(X - pad, Y - pad, W + 2*pad, H + 2*pad);
      octx.clip();

      // Glow
      octx.shadowColor = `rgba(255,255,255,${alpha.toFixed(3)})`;
      octx.shadowBlur  = blur;
      octx.globalAlpha = 1.0;
      octx.drawImage(headImg, X, Y, W, H);

      // Core
      octx.shadowBlur = 0;
      octx.shadowColor = 'transparent';
      octx.drawImage(headImg, X, Y, W, H);
      octx.restore();
    });

    pruneTracks();
  }

  function initFace(){
    const faceMesh = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({
      maxNumFaces: 8,               // more faces
      refineLandmarks: true,
      minDetectionConfidence: 0.30, // more permissive for small faces
      minTrackingConfidence: 0.40
    });
    const cam = new Camera(webcam,{
      onFrame: async()=>{ await faceMesh.send({ image: webcam }); },
      width: 1280, height: 720
    });
    cam.start();
    faceMesh.onResults((res)=>{
      if(res.multiFaceLandmarks && res.multiFaceLandmarks.length){
        drawHeads(res.multiFaceLandmarks);
      }else{
        octx.clearRect(0,0,ocan.width,ocan.height);
      }
    });
  }
  </script>
</body>
</html>


