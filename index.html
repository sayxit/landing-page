<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sayxit</title>
  <link rel="icon" type="image/png" href="assets/favicon.png">
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #webcam, #fallback {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover; background: #000;
    }
    .logo-top { position: fixed; top: 5px; left: 50%; transform: translateX(-50%); z-index: 3; }
    .logo-top img { max-width: 140px; height: auto; display:block; }
    #overlayCanvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }
    .footer { position: fixed; left:0; right:0; bottom:14px; display:flex; justify-content:center; gap:14px; z-index:3; }
    .footer a { width:22px; height:22px; display:block; }
    .footer a.social img { filter: invert(1); }
    .footer img { width:22px; height:22px; display:block; object-fit:contain; }
    .overlay { position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.6); color:#fff; z-index:4; font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .overlay.hidden { display:none; }
    #startBtn { position:fixed; bottom:70px; left:50%; transform:translateX(-50%); z-index:5; background:#fff; color:#000; border:0; border-radius:999px; padding:10px 16px; font-weight:600; cursor:pointer; }
  </style>

  <style id="clickfix">
    #glcanvas, #fxcanvas, canvas.stage { pointer-events: none !important; }
    video#webcam, video#fallback { pointer-events: none !important; }
    .top-logo, #top-logo { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; pointer-events: auto !important; }
    .top-logo a, #top-logo a { display: inline-block; }
  </style>

  <style id="overlayfix">
    .overlay { pointer-events: none !important; }
  </style>
</head>
<body>
  <video id="webcam" autoplay playsinline muted></video>
  <video id="fallback" autoplay playsinline muted loop style="display:none">
    <source src="assets/fallback.mp4" type="video/mp4" />
  </video>

  <canvas id="overlayCanvas"></canvas>

  <div class="logo-top"><a href="https://sayxit.com" target="_blank" rel="noopener"><img src="assets/top_logo.png" alt="SayXit Logo"></a></div>

  <div id="overlay" class="overlay"><div>Turn on your camera fam âœ¨</div></div>
  <button id="startBtn">Start</button>

  <div class="footer">
    <a class="social" href="https://www.instagram.com/sayxit/" target="_blank" rel="noopener"><img src="assets/instagram.svg" alt="Instagram"></a>
    <a class="social" href="https://www.tumblr.com/sayxit" target="_blank" rel="noopener"><img src="assets/tumblr.svg" alt="Tumblr"></a>
    <a href="mailto:selim@sayxit.com" rel="noopener"><img src="assets/email.png" alt="Email"></a>
    <a class="social" href="https://www.tiktok.com/@sayxit" target="_blank" rel="noopener"><img src="assets/tiktok.svg" alt="Tiktok"></a>
    <a class="social" href="https://www.youtube.com/@sayxxit" target="_blank" rel="noopener"><img src="assets/youtube.svg" alt="YouTube"></a>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  const webcam = document.getElementById('webcam');
  const fallback = document.getElementById('fallback');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const ocan = document.getElementById('overlayCanvas');
  const octx = ocan.getContext('2d');
  const headImg = new Image(); headImg.src = 'assets/head_logo.png';

  // Hi-DPI aware resize (crisper on Retina; same CSS size)
  function resize(){
    const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    ocan.style.width  = innerWidth + 'px';
    ocan.style.height = innerHeight + 'px';
    ocan.width  = Math.round(innerWidth  * DPR);
    ocan.height = Math.round(innerHeight * DPR);
    octx.setTransform(DPR, 0, 0, DPR, 0, 0); // draw in CSS pixels
  }

  // Responsive halo behavior (phone/tablet/desktop)
  const HALO_CFG = {
    liftByHeadWidth: 0.95,
    sizeByHeadWidth: 3.50,
    smoothPosAlpha: 0.18,
    smoothScaleAlpha: 0.20,
    visibilityMin: 0.50
  };
  function updateHaloResponsive(){
    const shortSide = Math.min(innerWidth, innerHeight);
    if (shortSide < 500) {           // phones
      HALO_CFG.sizeByHeadWidth = 4.30;
      HALO_CFG.liftByHeadWidth = 1.05;
    } else if (shortSide < 900) {    // small tablets
      HALO_CFG.sizeByHeadWidth = 3.90;
      HALO_CFG.liftByHeadWidth = 1.00;
    } else {                         // laptops/desktops
      HALO_CFG.sizeByHeadWidth = 3.50;
      HALO_CFG.liftByHeadWidth = 0.95;
    }
  }

  function handleResize(){
    resize();
    updateHaloResponsive();
  }
  addEventListener('resize', handleResize, {passive:true});
  handleResize();

  async function startCamera(){
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      webcam.srcObject = stream; await webcam.play();
      overlay.classList.add('hidden'); startBtn.style.display='none'; fallback.style.display='none';
      initFace();
    } catch(e){
      overlay.classList.add('hidden'); startBtn.style.display='inline-block';
      fallback.style.display='block'; try{ await fallback.play(); }catch{}
    }
  }
  document.addEventListener('DOMContentLoaded', startCamera);
  startBtn.addEventListener('click', startCamera);

  // Breathing halo controls (4s cycle unchanged)
  let __haloT0 = performance.now();
  const GLOW = {
    BLUR_MIN: 0,
    BLUR_MAX: 60,
    ALPHA_MIN: 0.35,
    ALPHA_MAX: 1.0,
    SPEED_HZ: 0.25,
    CLIP_PAD_PX: 140
  };

  // Anti-jitter + smoothing state
  const haloState = { x:null, y:null, w:null, h:null, scale:null };
  const lerp = (a,b,t)=> (a==null ? b : a + (b-a)*t);
  const px = v => Math.round(v); // snap to integers to reduce shimmer

  function drawHeads(lmsList){
    octx.clearRect(0,0,ocan.width,ocan.height);
    if(!lmsList || !lmsList.length || !headImg.complete) return;

    // Choose face closest to center
    let best = lmsList[0];
    if (lmsList.length > 1) {
      const cx = 0.5, cy = 0.5;
      let bestD = 9e9;
      for (const lm of lmsList) {
        const tL = lm[127], tR = lm[356];
        const mx = (tL.x + tR.x) * 0.5, my = (tL.y + tR.y) * 0.5;
        const d = (mx - cx) * (mx - cx) + (my - cy) * (my - cy);
        if (d < bestD) { bestD = d; best = lm; }
      }
    }

    // Confidence gate
    if (best[10].visibility !== undefined && best[10].visibility < HALO_CFG.visibilityMin) return;

    // Scale from temples; fallback to eye width
    const L = best[127], R = best[356];
    const eyeL = best[33], eyeR = best[263];
    const headW = Math.hypot((R.x - L.x) * innerWidth, (R.y - L.y) * innerHeight);
    const eyeW  = Math.hypot((eyeR.x - eyeL.x) * innerWidth, (eyeR.y - eyeL.y) * innerHeight);
    const baseScale = headW > 0 ? headW : eyeW;

    // Forehead anchor (nose bridge top blended with brow)
    const noseTop = best[10];
    const browMid = best[151] || best[9];
    const ax = ((noseTop.x + browMid.x) * 0.5) * innerWidth;
    const ay = (Math.min(noseTop.y, browMid.y)) * innerHeight;

    // Target geometry (device-agnostic via head width)
    const lift = HALO_CFG.liftByHeadWidth * baseScale;
    const size = HALO_CFG.sizeByHeadWidth * baseScale;

    const tw = size;
    const th = tw * (headImg.height / headImg.width);
    const tx = ax - tw / 2;
    const ty = (ay - lift) - th / 2;

    // Smooth state
    haloState.scale = lerp(haloState.scale, baseScale, HALO_CFG.smoothScaleAlpha);
    haloState.w = lerp(haloState.w, tw, HALO_CFG.smoothScaleAlpha);
    haloState.h = lerp(haloState.h, th, HALO_CFG.smoothScaleAlpha);
    haloState.x = lerp(haloState.x, tx, HALO_CFG.smoothPosAlpha);
    haloState.y = lerp(haloState.y, ty, HALO_CFG.smoothPosAlpha);

    // Breathing glow
    const t = (performance.now() - __haloT0) * 0.001;
    const s = Math.sin(t * 2 * Math.PI * GLOW.SPEED_HZ) * 0.5 + 0.5;
    const blur  = GLOW.BLUR_MIN  + (GLOW.BLUR_MAX  - GLOW.BLUR_MIN)  * s;
    const alpha = GLOW.ALPHA_MIN + (GLOW.ALPHA_MAX - GLOW.ALPHA_MIN) * s;

    // Snap to pixels to reduce shimmer
    const X = px(haloState.x), Y = px(haloState.y), W = px(haloState.w), H = px(haloState.h);

    // Glow (locally clipped)
    octx.save();
    octx.beginPath();
    const pad = GLOW.CLIP_PAD_PX;
    octx.rect(X - pad, Y - pad, W + 2*pad, H + 2*pad);
    octx.clip();
    octx.shadowColor = `rgba(255,255,255,${alpha.toFixed(3)})`;
    octx.shadowBlur  = blur;
    octx.globalAlpha = 1.0;
    octx.drawImage(headImg, X, Y, W, H);

    // Core
    octx.shadowBlur = 0;
    octx.shadowColor = 'transparent';
    octx.drawImage(headImg, X, Y, W, H);
    octx.restore();
  }

  function initFace(){
    const faceMesh = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    const cam = new Camera(webcam,{ onFrame: async()=>{ await faceMesh.send({ image: webcam }); }, width: 640, height: 480 });
    cam.start();
    faceMesh.onResults((res)=>{
      if(res.multiFaceLandmarks && res.multiFaceLandmarks.length){
        drawHeads(res.multiFaceLandmarks);
      }else{
        octx.clearRect(0,0,ocan.width,ocan.height);
      }
    });
  }
  </script>
</body>
</html>

